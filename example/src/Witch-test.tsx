/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 --types witch-test.glb 
*/

import * as THREE from 'three';
import React, {
  useEffect,
  useRef,
  useImperativeHandle,
  forwardRef,
} from 'react';
import { ThreeElements } from '@react-three/fiber';
import { useGLTF, useAnimations } from '@react-three/drei';

type GLTFResult = {
  nodes: {
    Circle: THREE.Mesh;
    Cube: THREE.Mesh;
    Cube001_1: THREE.Mesh;
    Cube002: THREE.Mesh;
    Cube003: THREE.Mesh;
    Cube007: THREE.Mesh;
    NurbsPath: THREE.Mesh;
    NurbsPath001: THREE.Mesh;
    NurbsPath002: THREE.Mesh;
    NurbsPath003: THREE.Mesh;
    NurbsPath004: THREE.Mesh;
    NurbsPath005: THREE.Mesh;
    NurbsPath006: THREE.Mesh;
    NurbsPath007: THREE.Mesh;
    NurbsPath008: THREE.Mesh;
    NurbsPath009: THREE.Mesh;
    NurbsPath010: THREE.Mesh;
    NurbsPath011: THREE.Mesh;
    NurbsPath012: THREE.Mesh;
    NurbsPath013: THREE.Mesh;
    NurbsPath014: THREE.Mesh;
    NurbsPath015: THREE.Mesh;
    Circle001: THREE.SkinnedMesh;
    Cylinder001: THREE.Mesh;
    Cube004: THREE.SkinnedMesh;
    Cube005: THREE.SkinnedMesh;
    Cube006: THREE.SkinnedMesh;
    Cylinder: THREE.SkinnedMesh;
    root: THREE.Bone;
    ['MCH-torsoparent']: THREE.Bone;
    Bone: THREE.Bone;
    neutral_bone: THREE.Bone;
    ['MCH-hand_ikparentL']: THREE.Bone;
    ['MCH-upper_arm_ik_targetparentL']: THREE.Bone;
    ['MCH-hand_ikparentR']: THREE.Bone;
    ['MCH-upper_arm_ik_targetparentR']: THREE.Bone;
    ['MCH-foot_ikparentL']: THREE.Bone;
    ['MCH-thigh_ik_targetparentL']: THREE.Bone;
    ['MCH-foot_ikparentR']: THREE.Bone;
    ['MCH-thigh_ik_targetparentR']: THREE.Bone;
  };
  materials: {
    ['Material.004']: THREE.MeshStandardMaterial;
    ['Material.005']: THREE.MeshStandardMaterial;
    ['Material.002']: THREE.MeshStandardMaterial;
    ['Material.006']: THREE.MeshStandardMaterial;
    ['Material.007']: THREE.MeshStandardMaterial;
    ['Material.001']: THREE.MeshStandardMaterial;
    ['Material.002']: THREE.MeshStandardMaterial;
    ['Material.003']: THREE.MeshStandardMaterial;
    Material: THREE.MeshStandardMaterial;
  };
};

type ModelProps = ThreeElements['group'];

// Attack combo sequence (skipping sword-attack-02)
const ATTACK_COMBO = [
  'sword-attack-01',
  'sword-attack-03',
  'sword-attack-04',
] as const;

export type ModelHandle = {
  setAnimation: (name: string) => void;
  attack: () => void;
  isAttacking: () => boolean;
};

export const Model = forwardRef<ModelHandle, ModelProps>((props, ref) => {
  const group = React.useRef<THREE.Group>(null);
  const { nodes, materials, animations } = useGLTF(
    '/witch-test.glb'
  ) as unknown as GLTFResult & { animations: THREE.AnimationClip[] };
  const { actions, mixer } = useAnimations(animations, group);

  const sword = useRef<THREE.Mesh>(null);

  // All state in refs - no re-renders
  const currentAnimation = useRef<string>('idle-sword');
  const isAttacking = useRef(false);
  const comboIndex = useRef(0);
  const nextAttackQueued = useRef(false);
  const baseAnimation = useRef<string>('idle-sword');

  // Play animation without re-render
  const playAnimation = (name: string, fadeIn = 0.2) => {
    if (currentAnimation.current === name) return;

    // Fade out current
    if (currentAnimation.current && actions[currentAnimation.current]) {
      actions[currentAnimation.current]?.fadeOut(fadeIn);
    }

    // Fade in new
    if (actions[name]) {
      const action = actions[name]?.reset().fadeIn(fadeIn).play();
      if (name === 'run') {
        action?.setEffectiveTimeScale(2);
      }
      // Set attack animations to play once
      if (ATTACK_COMBO.includes(name as (typeof ATTACK_COMBO)[number])) {
        action?.setLoop(THREE.LoopOnce, 1);
        if (action) action.clampWhenFinished = true;
      }
    }

    currentAnimation.current = name;
  };

  // Handle attack combo
  const attack = () => {
    if (!isAttacking.current) {
      // Start new combo
      isAttacking.current = true;
      comboIndex.current = 0;
      nextAttackQueued.current = false;
      playAnimation(ATTACK_COMBO[0], 0.1);
    } else {
      // Queue next attack in combo
      nextAttackQueued.current = true;
    }
  };

  // Handle animation finished
  useEffect(() => {
    if (group.current) {
      group.current.traverse((child) => {
        if ('isMesh' in child && child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
        if (child.name === 'Cylinder001') {
          console.log('sword', child);
          sword.current = child as THREE.Mesh;
          sword.current.visible = false;
        }
      });
    }
    const onFinished = (e: { action: THREE.AnimationAction }) => {
      const finishedName = e.action.getClip().name;

      // Check if it was an attack animation
      if (
        ATTACK_COMBO.includes(finishedName as (typeof ATTACK_COMBO)[number])
      ) {
        if (
          nextAttackQueued.current &&
          comboIndex.current < ATTACK_COMBO.length - 1
        ) {
          // Play next attack in combo
          comboIndex.current++;
          nextAttackQueued.current = false;
          playAnimation(ATTACK_COMBO[comboIndex.current], 0.1);
        } else {
          // Combo ended, return to base animation
          isAttacking.current = false;
          comboIndex.current = 0;
          nextAttackQueued.current = false;
          playAnimation(baseAnimation.current, 0.2);
        }
      }
    };

    mixer?.addEventListener('finished', onFinished);
    return () => {
      mixer?.removeEventListener('finished', onFinished);
    };
  }, [mixer, actions]);

  // Expose methods via ref
  useImperativeHandle(
    ref,
    () => ({
      setAnimation: (name: string) => {
        baseAnimation.current = name;
        if (!isAttacking.current) {
          playAnimation(name);
        }
      },
      attack,
      isAttacking: () => isAttacking.current,
    }),
    [actions]
  );

  // Initial setup
  useEffect(() => {
    actions['wind']?.play();
    playAnimation('idle-sword');
  }, [actions]);
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="BÃ©zierCircle" position={[-1.267, 0, 0]} />
        <group name="rig">
          <primitive object={nodes.root} />
          <primitive object={nodes['MCH-torsoparent']} />
          <primitive object={nodes['MCH-hand_ikparentL']} />
          <primitive object={nodes['MCH-upper_arm_ik_targetparentL']} />
          <primitive object={nodes['MCH-hand_ikparentR']} />
          <primitive object={nodes['MCH-upper_arm_ik_targetparentR']} />
          <primitive object={nodes['MCH-foot_ikparentL']} />
          <primitive object={nodes['MCH-thigh_ik_targetparentL']} />
          <primitive object={nodes['MCH-foot_ikparentR']} />
          <primitive object={nodes['MCH-thigh_ik_targetparentR']} />
          <skinnedMesh
            name="Cube004"
            geometry={nodes.Cube004.geometry}
            material={materials['Material.002']}
            skeleton={nodes.Cube004.skeleton}
          />
          <skinnedMesh
            name="Cube005"
            geometry={nodes.Cube005.geometry}
            material={materials['Material.003']}
            skeleton={nodes.Cube005.skeleton}
          />
          <skinnedMesh
            name="Cube006"
            geometry={nodes.Cube006.geometry}
            material={materials.Material}
            skeleton={nodes.Cube006.skeleton}
          />
          <skinnedMesh
            name="Cylinder"
            geometry={nodes.Cylinder.geometry}
            material={materials['Material.007']}
            skeleton={nodes.Cylinder.skeleton}
          />
          {/* <primitive object={nodes.Cylinder001} /> */}
        </group>
        <group name="Plane" />
      </group>
    </group>
  );
});

useGLTF.preload('/witch-test.glb');
